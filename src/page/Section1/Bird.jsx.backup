import React, { useEffect, useState, useRef } from "react";
import BirdImg from "../../assets/birdImg.svg";

export const Bird = ({ isNavScrolling, setIsNavScrolling }) => {
  const [offset, setOffset] = useState(0);
  const [hasScrolled, setHasScrolled] = useState(false);
  const [windowWidth, setWindowWidth] = useState(window.innerWidth);
  const [scrollDirection, setScrollDirection] = useState("down");
  const birdSectionRef = useRef(null);
  
  const smoothScrollTo = (targetPosition) => {
    const duration = 700;
    const start = window.scrollY;
    const distance = targetPosition - start;
    let startTime = null;

    const animation = (currentTime) => {
      if (startTime === null) startTime = currentTime;
      const timeElapsed = currentTime - startTime;
      const progress = Math.min(timeElapsed / duration, 1);

      const easeInOutQuad = (t) => (t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t);

      window.scrollTo(0, start + distance * easeInOutQuad(progress));

      if (timeElapsed < duration) {
        requestAnimationFrame(animation);
      }
    };

    requestAnimationFrame(animation);
  };

  useEffect(() => {
    const handleScroll = () => {
      requestAnimationFrame(() => {
        if (window.scrollY < 50) {
          setHasScrolled(false);
        }

        if (
          !hasScrolled &&
          window.scrollY > 50 &&
          window.scrollY < window.innerHeight
        ) {
          setHasScrolled(true);
          setIsNavScrolling(false);
          const targetHeight =
            window.innerWidth <= 1199.98
              ? window.innerHeight * 2
              : window.innerHeight * 3.3;
          console.log(isNavScrolling, "test 1");

          if (!isNavScrolling) {
            smoothScrollTo(targetHeight);
          }
        }

        const scrollY = window.scrollY;
        const viewportHeight = window.innerHeight;
        setOffset(Math.min(scrollY, viewportHeight * 2.7));
      });
    };

    window.addEventListener("scroll", handleScroll, { passive: true });
    return () => window.removeEventListener("scroll", handleScroll);
  }, [hasScrolled, isNavScrolling]);

  useEffect(() => {
    let lastScrollTop = 0;
    const handleScroll = () => {
      const currentScrollTop =
        window.pageYOffset || document.documentElement.scrollTop;
      const birdRect = birdSectionRef.current.getBoundingClientRect();

      const isInBirdSection =
        birdRect.top <= 0 &&
        birdRect.bottom >= 0 &&
        currentScrollTop <=
          (window.innerWidth <= 1199.98
            ? window.innerHeight * 2
            : window.innerHeight * 3);

      if (currentScrollTop < lastScrollTop) {
        setScrollDirection("up");
        if (isInBirdSection) {
          window.scrollTo({
            top: 0,
            behavior: "smooth",
          });
        }
      } else {
        setScrollDirection("down");
      }
      lastScrollTop = currentScrollTop;
    };

    window.addEventListener("scroll", handleScroll);
    return () => window.removeEventListener("scroll", handleScroll);
  }, []);

  useEffect(() => {
    const handleResize = () => {
      setWindowWidth(window.innerWidth);
    };

    window.addEventListener("resize", handleResize, { passive: true });
    return () => window.removeEventListener("resize", handleResize);
  }, []);

  const getScaleMultiplier = () => {
    const width = window.visualViewport?.width || window.innerWidth;
    if (width <= 575.98) return 0.05;
    if (width <= 767.98) return 0.05;
    if (width <= 991.98) return 0.08;
    if (width <= 1199.98) return 0.015;
    if (width <= 1399.98) return 0.02;
    return 0.002;
  };

  const getTranslateMultiplier = () => {
    const width = window.innerWidth;
    if (width <= 575.98) return { x: 0.5, y: 5 };
    if (width <= 767.98) return { x: 0.1, y: 10 };
    if (width <= 991.98) return { x: 0.3, y: 0.28 };
    if (width <= 1199.98) return { x: 0.45, y: 0.3 };
    if (width <= 1399.98) return { x: 0.48, y: 0.31 };
    return { x: 0.5, y: 0.315 };
  };

  const getCaptionStyle = () => {
    const translateY = -Math.min(offset * 0.5, window.innerHeight * 0.5);
    const opacity = Math.max(1 - offset / (window.innerHeight * 0.8), 0);

    return {
      transform: `translateY(${translateY}px)`,
      opacity,
      transition: "transform 0.3s ease-out, opacity 0.3s ease-out",
    };
  };

  // cycling last word
  const words = ["brand", "business", "marketing"];
  const [wordIndex, setWordIndex] = useState(0);
  const [isAnimating, setIsAnimating] = useState(false);
  
  // Calculate fixed width based on the longest word
  const getFixedWidth = () => {
    const longestWord = words.reduce((a, b) => a.length > b.length ? a : b);
    // Approximate character width based on font size - adjust as needed
    const charWidth = window.innerWidth <= 575.98 ? 1.2 : 1.2; // rem units
    return `${longestWord.length * charWidth}rem`;
  };

  useEffect(() => {
    const intervalId = setInterval(() => {
      setIsAnimating(true);
      
      setTimeout(() => {
        setWordIndex((prev) => (prev + 1) % words.length);
        setIsAnimating(false);
      }, 200); // Shorter duration to prevent stuck effect
    }, 2000);
    return () => clearInterval(intervalId);
  }, []);

  return (
    <section
      id="bird"
      className="bird"
      ref={birdSectionRef}
      aria-label="Bird section"
    >
      <div
        className="caption"
        style={getCaptionStyle()}
        aria-label="Caption for the bird section"
      >
        <h1>
          Fix your{" "}
          <span 
            className="changing-word-container"
            style={{
              display: 'inline-block',
              width: getFixedWidth(),
              textAlign: 'left',
              position: 'relative'
            }}
          >
            <span 
              className="changing-word"
              style={{
                position: 'relative',
                transition: 'all 0.2s ease-out',
                textAlign: 'left',
                fontSize: '3rem',
                fontWeight: '100',
                display: 'inline-block',
                transform: isAnimating ? 'translateY(-20px)' : 'translateY(0)',
                opacity: isAnimating ? 0 : 1,
              }}
            >
              {words[wordIndex]}
            </span>
            
            {/* Next word coming from bottom */}
            {/* isAnimating && (
              <span 
                className="changing-word next-word"
                style={{
                  position: 'absolute',
                  top: 0,
                  left: 0,
                  transition: 'opacity 0.3s ease-in-out, transform 0.3s ease-in-out',
                  textAlign: 'left',
                  fontSize: '3rem',
                  fontWeight: '100',
                  display: 'inline-block',
                  transform: 'translateY(30px)',
                  opacity: 1,
                  animation: 'slideInFromBottom 0.3s ease-in-out forwards'
                }}
              >
                {words[nextWordIndex]}
              </span>
            ) */}
          </span>
          <br /> 
          <span className="caption-span">with speed, strategy and execution trusted by 100+ businesses. </span>
        </h1>
      </div>
      <div className="bird-container" aria-label="Container for the bird image">
        <img
          className="bird-image"
          alt="A stylized bird representing Hawksee"
          src={BirdImg}
          aria-label="Stylized bird representing Hawksee"
          style={{
            transform: `translate3d(${offset * getTranslateMultiplier().x}px, ${offset * getTranslateMultiplier().y}px, 0) scale(${1 + offset * getScaleMultiplier()})`,
            transformOrigin: "center center",
            transition: scrollDirection === "up" 
              ? "transform 0.5s cubic-bezier(.73,.58,.83,.67)" 
              : "transform 1.3s cubic-bezier(.49,.41,.1,1.02)",
            willChange: "transform",
          }}
        />
      </div>
    </section>
  );
};
